{"version":3,"sources":["store.js","components/book-list-item/index.js","components/book-list-item/book-list-item.js","components/bookstore-service-context/bookstore-service-contex.js","components/hoc/with-bookstore-service.js","actions/index.js","utils/compose.js","components/spinner/index.js","components/spinner/spinner.js","components/error-indicator/index.js","components/error-indicator/error-indicator.js","components/book-list/book-list.js","components/book-list/index.js","components/shopping-cart-table/shopping-cart-table.js","components/shopping-cart-table/index.js","components/pages/home-page.js","components/pages/cart-page.js","components/shop-header/shop-header.js","components/shop-header/index.js","components/app/index.js","components/app/app.js","components/error-boundry/index.js","components/error-boundry/error-boundry.js","services/bookstore-service.js","reducers/book-list.js","reducers/shopping-cart.js","reducers/index.js","index.js"],"names":["timeout","BookListItem","book","onAddedToCart","title","author","price","coverImage","className","src","alt","onClick","React","createContext","BookstoreServiceProvider","Provider","BookstoreServiceConsumer","Consumer","withBookstoreService","Wrapped","props","bookstoreService","booksLoaded","newBooks","type","payload","booksError","error","booksAddedToCart","bookId","fetchBooks","dispatch","getBooks","then","data","catch","compose","funcs","component","reduceRight","wrapped","func","Spinner","ErrorIndicator","Booklist","books","map","key","id","BookListContainer","this","loading","Component","BookList","connect","bookList","ownProps","bindActionCreators","mapDispatchToProps","onIncrease","onDecrease","onDelete","ShoppingCartTable","shoppingCart","items","cartItems","total","orderTotal","item","i","count","HomePage","CartPage","ShopHeader","numItems","to","ShopHeaderContainer","reduce","sum","App","role","basename","path","exact","ErrorBoundry","state","hasError","setState","children","BookstoreService","Promise","resolve","reject","setTimeout","Math","random","Error","updateBookList","action","undefined","updateOrder","quantity","findBook","find","itemIndex","findIndex","idx","slice","updateCartItems","updateCartItem","updateShoppingCart","findItem","store","createStore","composeWithDevTools","applyMiddleware","thunkMiddleware","console","log","ReactDOM","render","value","document","getElementById"],"mappings":"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","file":"static/js/main.f16fff23.chunk.js","sourcesContent":["import { createStore, applyMiddleware } from 'redux';\nimport thunkMiddleware from 'redux-thunk';\nimport { reducer } from './reducers';\n// # Для работы Redux c DevTools\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\n/*\n   # Redux Store - (Центральный объект) Координирует работы с данными в Redux - приложении.\n    Компонент который организовывает работу функции Reducer и контролирует обновления state.\n    Чтобы его создать достаточно иметь Reducer, так как у него в параметрах уже установлено дефолт state и он его возвращает.\n\n    Чаще всего у сторонних библиотек есть методы по расширению их базового функционала\n      так как автор не может предусмотреть все варианты использования своей библиотекой,\n      а разаработчик предоставить функционал по расширению, изменению функционала.\n\n   ! monkey patching - замены какого-то метода в api на свою собственную реализацию\n      Применяется в крайних случаях когда сама библиотека не поддерживает никаких\n      механизмов расширения.\n\n  # В Redux есть возможность практически полностью изменять, расширять базовый функционал:\n    * 1) Store Enhancer - это функция высшего порядка, управляет процессом создания store.\n        Возвращает новую расширенную реализацию createStore подменяя оригинальную функцию createStore\n\n        * Принимает орг. функцию createStore -> возвращаемое новую версию createStore\n          const stringEnhancer = (createStore) => (...args) => {...}\n          createStore(stringEnhancer)\n      ! Если необходимо использовать несколько Store Enhancer, нужна функция compose от Redux\n\n    * 2) Middleware - это функция высшего порядка, которая модифицируют только то, как работает функция dispatch.\n      Middleware - промежуточный слой это кусок кода,\n      который выполняется после отправки action, но перед вызовом reducer.\n\n      Возвращает новый, расширенный dispatch подменяя тем самым, оригинальную функцию dispatch.\n      Для того чтобы использовать Middleware мы используем функцию applyMiddleware.\n\n      * АРГУМЕНТЫ:\n        - store - не полный, в котором есть метод store.getState() store.dispatch - орг. dispath\n        - dispatch ~ next - орг. функция dispatch или уже модифицированная версия\n        - action - вызванный action creator\n          возвращает новый модифицированный dispatch или передает его дальше в другой middleware\n        * const strMiddleware = (store) => (dispatch или next) => (action) => {...}\n          ИЛИ\n        * const middleware = ({ dispatch, getStore }) => (next) => (action) => {...}\n\n      * ВЫЗОВ:\n        const store = createStore(reducer, applyMiddleware(strMiddleware, logMiddleware));\n\n      * applyMiddleware - это store enhancer\n        единственный store enhancer, который идет в комплекте с Redux.\n        Работает примерно как compose, передает один модифицированный dispath в следующий\n          последняя модификация dispatch который передаст action в Reducer.\n          ! Поэтому dispatch - называется как next\n          ! В функцию applyMiddleware мы должны передать наши Middleware по очереди\n        - здесь очередь имеет значение.\n\n    ! Чаще всего менять механизм работы store не нужно (Store Enhancer),\n      в основном такая необходимость только в изменении механики работы dispatch(Middleware)\n\n    # Thunk (Middleware) - позволяет использовать функции в качестве action, вместо объекта\n*/\n\nconst strMiddleware = (store) => (dispatch) => (action) => {\n  if (typeof action === 'string') {\n    return dispatch({ type: action });\n  }\n  return dispatch(action);\n};\n\n// store - не полный, в котором есть метод store.getState()\n// dispatch ~ next - орг. функция dispatch\n// action - вызванный action creator\n// возвращает новый модифицированный dispatch или передает его дальше в другой\nconst logMiddleware = (store) => (dispatch) => (action) => {\n  console.log(action.type);\n  return dispatch(action);\n};\n\n// * Thunk\n// getState - функция получения объекта state\nconst delayedActionCreator = (timeout) => (dispatch) => {\n  setTimeout(() => {\n    dispatch({\n      type: 'DELAYED_ACTION',\n    });\n  }, timeout);\n};\n\n// * Инициализация Redux Store\nconst store = createStore(\n  reducer,\n  composeWithDevTools(applyMiddleware(thunkMiddleware, strMiddleware, logMiddleware))\n);\n\nstore.dispatch(delayedActionCreator(3000));\n\n// * Использования строки вместо объекта применение Middleware\nstore.dispatch('HELLO WORLD');\n\nexport default store;\n","import BookListItem from './book-list-item';\nexport default BookListItem;\n","import React from 'react';\nimport './book-list-item.css';\n\n// BookListContainer -> Booklist -> BookListItem\nconst BookListItem = ({ book, onAddedToCart }) => {\n  const { title, author, price, coverImage } = book;\n  return (\n    <div className='book-list-item'>\n      <div className='book-cover'>\n        <img src={coverImage} alt='cover' />\n      </div>\n      <div className='book-details'>\n        <div className='book-title'>{title}</div>\n        <div className='book-author'>{author}</div>\n        <div className='book-price'>${price}</div>\n        <button onClick={onAddedToCart} className='btn btn-info add-to-cart'>\n          Add to cart\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default BookListItem;\n","import React from 'react';\n\nconst {\n  Provider: BookstoreServiceProvider, // Переименовываю\n  Consumer: BookstoreServiceConsumer,\n} = React.createContext();\n\nexport { BookstoreServiceProvider, BookstoreServiceConsumer };\n","import React from 'react';\nimport { BookstoreServiceConsumer } from '../bookstore-service-context';\n\nconst withBookstoreService = () => (Wrapped) =>\n  function WithBookstoreService(props) {\n    return (\n      // Получаю доступ к Класс Сервису через внутреннюю функцию которая принимает сервис\n      // который мы передаем через BookstoreServiceProvider (REACT CONTEXT)\n      <BookstoreServiceConsumer>\n        {(bookstoreService) => {\n          return <Wrapped {...props} bookstoreService={bookstoreService} />;\n        }}\n      </BookstoreServiceConsumer>\n    );\n  };\n\nexport default withBookstoreService;\n","/*\n   ! Action Creator\n\n    Action - (обычный объект) Интерфейс общения между компонентами приложения и объектом STORE,\n    а так же его изменения.\n    У этого объекта должно быть поле type: \"СТРОКА которая описывает действие\"\n    Он так же может содержать дополнительные поля для использовании внутри функции Reducer.\n      store.dispatch({\n        type: 'USER_LOGGED_IN',\n        name: 'Arnold',\n        role: 'admin',\n      })\n    * Часто дополнительные параметры передают в поле payload\n\n    ! dispatch - всегда работает с тем store на котором он был создан\n\n    ! Могут быть не чистыми функциями, но лучше все таки были\n    Функции по созданию Action Creator\n    const userLoggedIn = (name, role) => {\n      return { type: 'USER_LOGGED_IN', name, role }\n    }\n    store.dispatch(userLoggedIn('Arnold', 'admin'));\n\n    # Если приложение большое, то строки type, лучше всего выносить const в отдельный файл action-types\n\n    # Naming Convention для type, которые занимаются получением данных\n      [тип запроса]_[объект]_[действие]\n\n      FETCH - запрос на получение данных\n      * FETCH_BOOKS_REQUEST - отправка запроса\n      * FETCH_BOOKS_SUCCESS - получения результата\n        (в payload передается полученные данные)\n      * FETCH_BOOKS_FAILURE - получения (обработка) ошибки\n        (в payload передается объект Error)\n\n      UPDATE - запрос на обновления\n      * UPDATE_BOOKS_REQEST\n\n      # Thunk (Middleware)\n        Thunk middleware - позволяет передавать в store функции, a не объекты Action.\n        Такие функции принимают dispatch() и getState() - можно вытащить данные и передать на backend\n\n          const getPerson = (id) => (dispatch, getState) => { // action creator\n              dispatch({ type: ‘FETCH_PERSON_REQUEST' });\n              fetchPerson(id) // асинхронное действие\n                  .then((data) => dispatch({ type: ‘FETCH_PERSON_SUCCESS’ }))\n                  .catch((error) => dispatch({ type: ‘FETCH_PERSON_FAILURE’, error}))\n          }\n*/\n\nconst booksRequested = () => ({\n  type: 'FETCH_BOOKS_REQUEST',\n});\n\nconst booksLoaded = (newBooks) => ({\n  type: 'FETCH_BOOKS_SUCCESS',\n  payload: newBooks,\n});\n\nconst booksError = (error) => ({\n  type: 'FETCH_BOOKS_FAILURE',\n  payload: error,\n});\n\nconst booksAddedToCart = (bookId) => ({\n  type: 'BOOK_ADDED_TO_CART',\n  payload: bookId,\n});\n\nconst booksRemovedFromCart = (bookId) => ({\n  type: 'BOOK_REMOVED_FROM_CART',\n  payload: bookId,\n});\n\nconst allBooksRemovedFromCart = (bookId) => ({\n  type: 'ALL_BOOKS_REMOVED_FROM_CART',\n  payload: bookId,\n});\n\n/*\n  ! Так как Логика получения, записи, и обработки данных\n  может быть понадобиться нескольким компонентам, ее можно вынести в Action.\n  В ней можно объединить несколько Action Creator, тем самым передавая  только\n  одну функцию с основно Логикой в mapDispatchToProps.\n*/\n\n// * Получения асинхронных данных через обычную функцию\n// Используется внутри mapDispatchToProps\nconst fetchBooksOld = (dispatch, bookstoreService) => () => {\n  // # 0) Сбрасываю Redux state в первоначальное состояние\n  // # 1) Получаю данные (Promise) из Класс Сервиса\n  // # 2) Передать действия (dispatch action)\n  // в React Store, он вызывает c переданным action.type Reducer\n  // который обновляет состояние state\n  // # 3) Обработка ошибки, и запись ее в Redux state\n  dispatch(booksRequested()); // 0\n  bookstoreService\n    .getBooks() // 1\n    .then((data) => dispatch(booksLoaded(data))) // 2\n    .catch((error) => dispatch(booksError(error))); // 3\n};\n\n// * Получения асинхронных данных через Thunk\nconst fetchBooks = (bookstoreService) => (...args) => (dispatch) => {\n  // Можно передать любые параметры в Thunk через компонент во время вызова\n\n  bookstoreService\n    .getBooks()\n    .then((data) => dispatch(booksLoaded(data)))\n    .catch((error) => dispatch(booksError(error)));\n};\n\nexport { fetchBooks, booksAddedToCart, booksRemovedFromCart, allBooksRemovedFromCart };\n","const compose = (...funcs) => (component) =>\n  funcs.reduceRight((wrapped, func) => func(wrapped), component);\n\nexport default compose;\n","import Spinner from './spinner';\nexport default Spinner;\n","import React from 'react';\nimport './spinner.css';\n\nconst Spinner = () => {\n  return <div>Loading...</div>;\n};\n\nexport default Spinner;\n","import ErrorIndicator from './error-indicator';\nexport default ErrorIndicator;\n","import React from 'react';\nimport './error-indicator.css';\n// import icon from './death-star.png'; // Webpack - кодирует в base64\n\n// # Компонент показа сообщения об ошибки\nconst ErrorIndicator = () => {\n  return <div className='error-indicator'>Error!</div>;\n};\n\nexport default ErrorIndicator;\n","import React, { Component } from 'react';\nimport BookListItem from '../book-list-item';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport { withBookstoreService } from '../hoc';\nimport { fetchBooks, booksAddedToCart } from '../../actions';\nimport { compose } from '../../utils';\n\nimport './book-list.css';\nimport Spinner from '../spinner';\nimport ErrorIndicator from '../error-indicator';\n\n/*\n  # connect - компонент высшего порядка HOC, который передает значения из store в компонент\n  connect(Конфигурация)(Компонент) - получить доступ к целому store в Provider.\n    Работает так же как и SwapiServiceConsumer\n    connect возвращает новый компонент который знает об Redux:\n      переданный компонент оборачивается, и теперь он будет брать данный из store.\n\n   # bindActionCreators(actionCreators, dispatch) - связывает функцию action creator c функцией dispath()\n      ! dispatch - всегда работает с тем store на котором он был создан\n\n    Созданные таким способом функции делают сразу два действия\n      - вызов действия в action creator и отправка его в dispatch()\n\n    * actionCreators(Функция или Объект):\n\n        bindActionCreators принимает объект\n            const mapDispatchToProps = (dispatch) => {\n              return bindActionCreators({\n                one: action creator\n              }, dispatch);\n            };\n\n        То вернет объект с ключами у которого будут названия функция которые хотим получить, внутри компонента.\n         А свойствах будет лежать анонимная функция внутри которой вместо оригинальный функций action creator,\n          получаем обернутую версию в которой он уже вызваны внутри dispatch и которую можно передать параметры\n          Reducer\n\n        Если вы передаете единственную функцию (один action creator),\n        возвращаемое значение также будет единственной функцией которая обернута и вызвана в dispatch\n\n      ! import * as actions from \"../actions\";\n      Можно connect передать вместо mapDispatchToProps, объект с action creators которые будут\n      которые будут скрыто обернуты в bindActionCreators(actions, dispatch)\n\n\n    # Конфигурация:\n      * 1) mapStateToProps:\n          (Функция) - нужна чтобы получить только нужные значения из Redux Store и передать их в Компонент через props\n\n      * 2) mapDispatchToProps: (ФУНКЦИЯ ИЛИ ОБЪЕКТ) - Action Creator будут передан в компонент.\n            Таким способом компонент может обновить состояние в store\n\n            ФУНКЦИЯ - возвращает объект свойствами которые будут функции,\n              внутри которых будут вызван метод dispatch внутри которого будет вызвана\n              функция action creator которая может принимать какие-то параметры из компонента\n              и передавать их в Reducer\n\n            mapDispatchToProps = (dispatch, ownProps)\n              booksLoaded: (newBooks) => {\n                    dispatch(booksLoaded(newBooks));\n                },\n              };\n\n            ОБЪЕКТ:\n              mapDispatchToProps = {\n                booksLoaded\n              }\n\n            ! Если в качестве второго аргумента connect передать mapDispatchToProps ~ объект,\n            ! то connect выполнит код за нас bindActionCreators(actions, dispatch)\n              То есть передаст функцию под свойством booksLoaded в компонент\n                function () {\n                  return dispatch(actionCreator.apply(this, arguments));\n                }\n\n        ! Использовать ОБЪЕКТ, необходимо когда все, что нужно сделать, это взять actions Creator и \"обернуть\"\n          их при помощи bindActionCreators.\n          Если коде mapDispatchToProps более сложная логика, то нужно использовать функцию.\n\n  # mapStateToProps и mapDispatchToProps есть вторгой аргумент: ownProps\n    ownProps - это props которые пришли от родительского компонента.\n      Props которые перешли от HOC функции withBookstoreService()\n      которая получит обернутый компонент connect(mapStateToProps, mapDispatchToProps)\n      тем самым внутри mapStateToProps, mapDispatchToProps можно получить те props\n      которые мы передали из withBookstoreService\n\n  # Component Container - Паттерн React-Redux - разделения логики и орисовки\n      Можно вынести все контейнеры в отдельную папку containers или PersonContainer и там держать все компоненты контайнеры\n      Компоненты-контайнеры работают с Redux, реализуют loading, error, другую Логику\n\n  ! Функция mapStateToProps выполняется всегда, когда запускается процесс рендеринга\n   компонента, даже если его данные не изменились (но изменились для каких-то других компонентов в этой же части дерева компонентов)\n*/\n\n// # (Презентационный) Компонент отвечает за отображение элементов - (ничего не знает о Логике)\nconst Booklist = ({ books, onAddedToCart }) => {\n  return (\n    <ul className='book-list'>\n      {books.map((book) => (\n        <li key={book.id}>\n          <BookListItem book={book} onAddedToCart={(id) => onAddedToCart(book.id)} />\n        </li>\n      ))}\n    </ul>\n  );\n};\n\n// # Компонент Контейнер - отвечает за Логику, но не за отображения\nclass BookListContainer extends Component {\n  componentDidMount() {\n    // Можно передать любые параметры в Thunk через компонент во время вызова\n    this.props.fetchBooks();\n  }\n\n  render() {\n    // Props из Redux Store через mapStateToProps\n    // # 4) После обновления state, через dispatch action,\n    // загружаются данные и обновляется компонент с этими данными\n    const { books, loading, error, onAddedToCart } = this.props;\n\n    if (loading) {\n      return <Spinner />;\n    }\n\n    if (error) {\n      return <ErrorIndicator />;\n    }\n\n    return <Booklist books={books} onAddedToCart={onAddedToCart} />;\n  }\n}\n\n// * Чтение данных из Redux Store\n// state - который определен в Reducer\nconst mapStateToProps = ({ bookList: { books, loading, error } }) => {\n  return { books, loading, error };\n};\n\n// * Отправка действий в Redux Store\n// Вся Логика работы с данными объединена в одной функции,и передается в компонент\n// fetchBooks включает себя три Action Creator и находится там же\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  // ownProps - это те props которые мы отправили из withBookstoreService -> bookstoreService\n  const { bookstoreService } = ownProps;\n\n  // ! Вызов Thunk через bindActionCreators\n  return bindActionCreators(\n    {\n      fetchBooks: fetchBooks(bookstoreService),\n      onAddedToCart: booksAddedToCart,\n    },\n    dispatch\n  );\n\n  /*\n    // ! Явный Thunk\n    return {\n      // * Через обычную функцию\n      // fetchBooks: fetchBooks(dispatch, bookstoreService),\n      // * Через Thunk\n      fetchBooks: () => dispatch(fetchBooks(bookstoreService)()),\n      onAddedToCart: (id) => dispatch(booksAddedToCart(id)),\n    };\n  */\n};\n\n// Возвращает обернутый HOC компонент получает доступ к Класс-Сервису\n// И через connect умеет брать данные из Redux и так же через Actions их изменять\nexport default compose(\n  withBookstoreService(),\n  connect(mapStateToProps, mapDispatchToProps)\n)(BookListContainer);\n\n/*\n  // ES5\n  // state - определен в Reducer\n  const mapStateToProps = (state) => {\n    return {\n      books: state.books,\n      loading: state.loading,\n      error: state.error,\n    };\n  };\n\n  // БЕЗ ACTION CREATOR\n  const mapDispatchToProps = (dispatch) => {\n    return {\n      booksLoaded: (newBooks) => {\n        dispatch({\n          type: 'BOOKS_LOADED',\n          payload: newBooks,\n        });\n      },\n    };\n  };\n\n  // БЕЗ bindActionsCreator c ACTION CREATOR\n  const mapDispatchToProps = (dispatch) => {\n  return {\n    booksLoaded: (newBooks) => {\n      dispatch(booksLoaded(newBooks));\n      },\n    };\n  };\n\n  // С bindActionsCreator, без Рефакторинга\n  const mapDispatchToProps = (dispatch) => {\n  const booksLoaded = bindActionCreators(booksLoaded, dispatch);\n    return {\n      booksLoaded: booksLoaded, ~ es5\n    };\n  };\n\n  // С bindActionsCreator, с Рефакторингом\n  const mapDispatchToProps = (dispatch) => {\n    return bindActionCreators({ booksLoaded ~ es6}, dispatch);\n  };\n\n  // БЕЗ Рефакторинга mapDispatchToProps + (работа с данными внутри componentDidMount)\n\n  // Передача объекта вторым агументом в connect\n  // REDUX сделает за нас bindActionCreators({ booksLoaded }, dispatch);\n  const mapDispatchToProps = {\n    booksLoaded, // Запись в state в Redux\n    booksRequested, // Сбросить state\n    booksError, // Обработка ошибки\n  };\n\n  componentDidMount() {\n    // bookstoreService Класс-Сервиса, который передаются через React Context\n    // booksLoaded - Active Creator обернутый в dispath передаются через Connect\n    const { bookstoreService, booksLoaded, booksRequested, booksError } = this.props;\n\n    // # 0) Сбрасываю Redux state в первоначальное состояние\n    booksRequested();\n    // # 1) Получаю данные (Promise)\n    // # 2) Передать действия (dispatch action)\n    // в React Store, он вызывает c переданным action.type Reducer\n    // который обновляет состояние state\n    // # 3) Обработка ошибки, и запись ее в Redux state\n    bookstoreService\n      .getBooks()\n      .then((data) => booksLoaded(data))\n      .catch((error) => booksError(error));\n  }\n*/\n","import BookList from './book-list';\nexport default BookList;\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  booksAddedToCart,\n  booksRemovedFromCart,\n  allBooksRemovedFromCart,\n} from '../../actions';\n\nimport './shopping-cart-table.css';\nconst ShoppingCartTable = ({ items, total, onIncrease, onDecrease, onDelete }) => {\n  // * Callback -> Элементы таблицы\n  const renderRow = (item, i) => {\n    const { id, title, count, price } = item;\n    return (\n      <tr key={id}>\n        <td>{i + 1}</td>\n        <td>{title}</td>\n        <td>{count}</td>\n        <td>${price}</td>\n        <td>\n          <button\n            onClick={() => onDelete(id)}\n            className='btn btn-outline-danger float-right'\n          >\n            <i className='fa fa-trash-o'></i>\n          </button>\n\n          <button\n            onClick={() => onIncrease(id)}\n            className='btn btn-outline-success float-right'\n          >\n            <i className='fa fa-plus-circle'></i>\n          </button>\n\n          <button\n            onClick={() => onDecrease(id)}\n            className='btn btn-outline-warning float-right'\n          >\n            <i className='fa fa-minus-circle'></i>\n          </button>\n        </td>\n      </tr>\n    );\n  };\n\n  return (\n    <div className='shopping-cart-table'>\n      <h2>Your Order</h2>\n      <table className='table'>\n        <thead>\n          <tr>\n            <th>#</th>\n            <th>Item</th>\n            <th>Count</th>\n            <th>Price</th>\n            <th>Action</th>\n          </tr>\n        </thead>\n        <tbody>{items.map(renderRow)}</tbody>\n      </table>\n\n      {/* Можно было было сделать так чтобы компонент сам считал total на основании других данных,\n      но правильнее держать это Логику в Reducer. Таким образом если она станет сложнее,\n      будет только одно место для изменения или обновления кода этой Логики.\n      */}\n      <div className='total'>Total: ${total}</div>\n    </div>\n  );\n};\n\nconst mapStateToProps = ({ shoppingCart: { cartItems, orderTotal } }) => ({\n  items: cartItems,\n  total: orderTotal,\n});\n\n// REDUX сделает за нас bindActionCreators({...}, dispatch);\nconst mapDispatchToProps = {\n  onIncrease: (id) => booksAddedToCart(id),\n  onDecrease: (id) => booksRemovedFromCart(id),\n  onDelete: (id) => allBooksRemovedFromCart(id),\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ShoppingCartTable);\n","import ShoppingCartTable from './shopping-cart-table';\nexport default ShoppingCartTable;\n","import React from 'react';\nimport BookList from '../book-list';\nimport ShoppingCartTable from '../shopping-cart-table';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <BookList />\n      <ShoppingCartTable />\n    </div>\n  );\n};\n\nexport default HomePage;\n","import React from 'react';\n\nconst CartPage = () => {\n  return <div>Cart Page</div>;\n};\n\nexport default CartPage;\n","import React, { Component } from 'react';\nimport './shop-header.css';\nimport { Link } from 'react-router-dom';\nimport { connect } from 'react-redux';\n\nconst ShopHeader = ({ numItems, total }) => {\n  return (\n    <header className='shop-header'>\n      <Link to='/' className='logo text-dark'>\n        Redux Store\n      </Link>\n\n      <Link to='/cart/' className='shopping-cart'>\n        <i className='cart-icon fa fa-shopping-cart' />\n        {numItems} items (${total})\n      </Link>\n    </header>\n  );\n};\n\nclass ShopHeaderContainer extends Component {\n  render() {\n    return <ShopHeader {...this.props} />;\n  }\n}\n\nconst mapStateToProps = ({ shoppingCart: { cartItems, orderTotal } }) => {\n  const numItems = cartItems.reduce((sum, { count }) => sum + count, 0);\n  return {\n    numItems,\n    total: orderTotal,\n  };\n};\n\nexport default connect(mapStateToProps)(ShopHeaderContainer);\n","import ShopHeader from './shop-header';\nexport default ShopHeader;\n","import App from './app';\nexport default App;\n","import React from 'react';\nimport { Route, Switch } from 'react-router-dom';\nimport { HomePage, CartPage } from '../pages';\nimport ShopHeader from '../shop-header';\n\nimport './app.css';\n\n/*\n  Подключение нового компоненты к Redux\n  Создать новый презентационный компонент. Он не должен 'знать' о Redux.\n  Обновить state в Reducer и добавить туда новые, необходимые поля для этого компонента\n  Можно для начала заполнить их тестовыми данными в state\n  Реализуйте функции для connect() и подключите компонент к Redux\n*/\n\nconst App = () => {\n  return (\n    <main role='main' className='container'>\n      <ShopHeader numItems={5} total={5} />\n      <Switch>\n        <Route basename='/' path='/' exact component={HomePage} />\n        <Route path='/cart' component={CartPage} />\n      </Switch>\n    </main>\n  );\n};\n\nexport default App;\n","import ErrorBoundry from './error-boundry';\nexport default ErrorBoundry;\n","import React, { Component } from 'react';\nimport ErrorIndicator from '../error-indicator/';\n\n// # Класс обработки ошибок в дочерних элементах, и вывода сообщения\nexport default class ErrorBoundry extends Component {\n  state = {\n    hasError: false,\n  };\n\n  componentDidCatch() {\n    this.setState({ hasError: true });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <ErrorIndicator />;\n    }\n\n    return this.props.children;\n  }\n}\n","/*\n  Класс сервис, настоящий бы работал с backend данными\n*/\n\nexport default class BookstoreService {\n  data = [\n    {\n      id: 1,\n      title: 'Production-Ready Microservices',\n      author: 'Susan J.Fowler',\n      price: 32,\n      coverImage:\n        'https://images-na.ssl-images-amazon.com/images/I/41yJ75gpV-L._SX381_BO1,204,203,200_.jpg',\n    },\n    {\n      id: 2,\n      title: 'Realese It!',\n      author: 'Michael T. Nygard',\n      price: 45,\n      coverImage:\n        'https://images-na.ssl-images-amazon.com/images/I/414CRjLjwgL._SX403_BO1,204,203,200_.jpg',\n    },\n  ];\n\n  // Возврат данные асинхронно\n  getBooks() {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        // 1/4 - случаях будет ошибка\n        if (Math.random() > 0.75) {\n          reject(new Error('Something bad happened!'));\n        } else {\n          resolve(this.data);\n        }\n      }, 800);\n    });\n  }\n}\n","// * Отвечает только за обновления части state: объекта bookList\nexport const updateBookList = (state, action) => {\n  // ! Инициализация собственной части state\n  if (state === undefined) {\n    // * bookList:\n    return {\n      books: [], // Данные с сервера\n      loading: true,\n      error: null,\n    };\n  }\n\n  // ! ...state - больше не нужно передавать оставшиеся поля\n  // После разделения reduser, работаем только с bookList\n  switch (action.type) {\n    // Начало загрузки книг, сброс state\n    case 'FETCH_BOOKS_REQUEST':\n      return {\n        books: [],\n        loading: true,\n        error: null,\n      };\n\n    // Книги загружены, запись в state\n    case 'FETCH_BOOKS_SUCCESS':\n      return {\n        books: action.payload,\n        loading: false,\n        error: null,\n      };\n\n    // В момент загрузки произошла ошибка\n    case 'FETCH_BOOKS_FAILURE':\n      return {\n        books: [],\n        loading: false,\n        error: action.payload, // Объект ошибки\n      };\n\n    // ! В функцию приходят action с updateShoppingCart\n    // ! Так как она их не знает, возвращаем тот объект с которым работает\n    default:\n      return state.bookList;\n  }\n};\n","// * Обновления списка покупок\n// item - тот элемент который будем добавляться, или заменять(обновлять) существующий элемент\n// idx - индекс найденой книги в массиве покупок\nconst updateCartItems = (cartItems, item, idx) => {\n  // Полностью удалить их таблицы покупок\n  // Если количество книг равно 0\n  if (item.count === 0) {\n    return [\n      ...cartItems.slice(0, idx), // до\n      ...cartItems.slice(idx + 1), // после\n    ];\n  }\n\n  // Добавленной новой книги если ее еще нету в массиве покупок\n  if (idx === -1) {\n    return [...cartItems, item];\n  }\n\n  // Значит книга уже есть, и ее и текущий state следует заменить(обновить)\n  return [\n    ...cartItems.slice(0, idx), // до\n    item,\n    ...cartItems.slice(idx + 1), // после\n  ];\n};\n\n// * Добавления новой или обновления(+1, -1, -все) книги в таблице покупок\n// Вместо того, чтобы рассматривать, существует ли предыдущий элемент или нет\n// Можно сказать, что предыдущий элемент существует всегда\n// и через значения по умолчанию задавать ему значения\nconst updateCartItem = (book, item = {}, quantity) => {\n  // Если item === undefined, тогда {}\n  // и тогда его значения будут либо по умолчанию, либо:\n  const { id = book.id, title = book.title, count = 0, price = 0 } = item;\n\n  // Книга есть в массиве покупок, ее нужно обновить\n  return {\n    id,\n    title,\n    count: count + quantity, // 1 + 1 || 1 + (-1)\n    price: price + quantity * book.price, // 30 + (-1 * 30) = 30 - 30\n  };\n};\n\n// * Обновления таблицы покупок\nconst updateOrder = (state, bookId, quantity) => {\n  const {\n    bookList: { books },\n    shoppingCart: { cartItems, orderTotal },\n  } = state;\n\n  // Выбранная книга из массива книг полученных с сервера\n  const findBook = books.find((book) => book.id === bookId);\n  // id выбранной книги в массиве покупок\n  const itemIndex = cartItems.findIndex((book) => book.id === bookId);\n  // Нахождения выбранной книги в массиве покупок\n  const oldItem = cartItems[itemIndex];\n  // Новая или обновленная книга\n  const newItem = updateCartItem(findBook, oldItem, quantity);\n  // Обновленный массив покупок\n  const newCartItems = updateCartItems(cartItems, newItem, itemIndex);\n\n  return {\n    cartItems: newCartItems,\n    // 0 + 45 * 1 -> 45 + 45 + 1 -> 90 + 45 * -1\n    orderTotal: orderTotal + findBook.price * quantity,\n  };\n};\n\n// * Отвечает только за обновления части state: объекта shoppingCart\nexport const updateShoppingCart = (state, action) => {\n  // ! Инициализация собственной части state\n  if (state === undefined) {\n    // * shoppingCart:\n    return {\n      cartItems: [], // Покупки\n      orderTotal: 0, // Общий счет\n      numItems: 0,\n    };\n  }\n\n  switch (action.type) {\n    // Добавления (Обновление) полученой с сервера книги, в таблице покупок\n    case 'BOOK_ADDED_TO_CART':\n      return updateOrder(state, action.payload, 1);\n\n    case 'BOOK_REMOVED_FROM_CART':\n      return updateOrder(state, action.payload, -1);\n\n    case 'ALL_BOOKS_REMOVED_FROM_CART':\n      const findItem = state.shoppingCart.cartItems.find(\n        ({ id }) => id === action.payload\n      );\n      // -все книги\n      return updateOrder(state, action.payload, -findItem.count);\n\n    default:\n      return state.shoppingCart;\n  }\n};\n","/*\n  ! Сперва стоит с 'формы' state, а затем писать для него reducers\n    а не наоборот (начинать с функций и \"подгонять\" под них state).\n\n  ! Reducer - (Логика) Функция которая знает как обновлять глобальное состояние state,\n    для любого события в приложении.\n    Принимает два параметра:\n      * 1) state - текущее состояние\n      * 2) action - действие которое нужно совершить\n\n    # Reducer должен вернуть полное состояние нового state\n        не только те ключи которые следует обновить, полностью весь объект который\n        будет новым state, a не частичное как в setState({})\n\n    # Если state (undefined), необходимо вернуть первоначальное состояние.\n        В параметрах в Reducer state, выставить дефолт состояние: state = 0 - дефолтное значение\n\n    # Если Reducer не знает какого-то действия (action.type), то необходимо вернуть\n        state без изменения.\n\n    ! Функция Reducer - должна быть чистой функцией:\n      * 1. Возвращаемое значение зависит только от аргументов.\n          Всегда возвращает одинаковое состояние при одинаковых переданных аргументах.\n\n          Читая: (a, b) => a > b ? a : b\n          Нет: (a) => Math.random() * a.\n            Результат зависит от того какое число вернут Math.random\n\n      * 2. У функции нет побочных эффектов\n          (запись значения в глобальную переменную,\n          обновления DOM дерева,\n          запись значения в кеш, базу данных, localStore)\n\n          Не может менять глобальное состояние и аргументы\n          Может менять только собственные локальные состояние, собственные локальные переменные.\n\n          Нет:\n            const render () => document.getElementById('root').innerHTML = 'hi'\n            Меняет внешнее значение NODE в document\n          Нет: const render = (el) => el.innerHTML = 'hi' - Модифицирует аргумент\n\n          Любые функции которые модифицируют DOM, вызывают server, устанавливают setTimeout,\n            исп. Math.random, текущее время - НЕ ЯВЛЯЮТСЯ ЧИСТЫМИ, ОНИ ЗАВИСЯТ ОТ ВНЕШНИХ РЕСУРСОВ\n\n\n    ! Не все функции, которые работают с redux обязаны быть reducer'ами.\n        В reducer'е вы совершенно спокойно можете использовать обычные вспомогательные функции\n        (при условии, что они чистые).\n\n    # Как правильно организовать код Reducer при маштабировании\n        Как только reducer становится сложным - необходимо сразу упрощайте его\n        работайте со структурой глобального state: объединяйте свойства в объекты,\n        вынося логику обновления объектов из глобального state в отдельные функции\n\n      Попытаться разделить действия по категориям и разбить Reducer на более мелкие функции\n        - действия которые работают со списком книг (books)\n        - действия которые работают со списком заказов (cartItems)\n\n    # combineReducers -  работает, только когда reducer абсолютно независимы\n      Главный аспект работы combineReducers - каждая функция reducer - независимая,\n          и она должна работать как независимый reduser, ее initialState не завивист от другого\n\n      ! В данном случае state завит от другой \"ветки-объекта\"\n        и поэтому combineReducers использовать нельзя.\n  */\n\n// ! Первоначальный State, нельзя мутировать (изменять)\n\n// * Вспомогательные функции, которы отвечают за свою часть state\nimport { updateBookList } from './book-list';\nimport { updateShoppingCart } from './shopping-cart';\n\n/*\n  * Так выглядит state\n  initialState = {\n    // Данные с сервера\n    books: [],\n      loading: true,\n      error: null,\n    },\n    // Таблица покупок\n    shoppingCart: {\n      cartItems: [],\n      orderTotal: 0,\n    };\n  }\n*/\n\n// * Основной Reducer\n// Reducer больше не отвечает за первоначальное состояние initialState\n// Каждая часть state инициализируется внутри вспомогательных функции\nconst reducer = (state, action) => {\n  // Использует две вспомогательные функции\n  // Которые обрабатывают, обновляют только свою структуру state\n  return {\n    bookList: updateBookList(state, action),\n    shoppingCart: updateShoppingCart(state, action),\n  };\n};\n\nexport { reducer };\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport App from './components/app';\nimport ErrorBoundry from './components/error-boundry';\nimport BookstoreService from './services/bookstore-service';\nimport { BookstoreServiceProvider } from './components/bookstore-service-context';\nimport store from './store';\n\n/*\n   Базовая структура папок в проекте:\n    /services - сервис по работе с данными, backend\n    /utils\n    /actions\n    /reducers\n    index.js\n    store.js\n\n  /components\n    /app\n    /pages\n    /spinner\n    /error-indicator\n    /error-boundry\n    /hoc\n    /bookstore-service-context - react context\n\n    ! Центром Логики приложения является Redux поэтому самый верхний элемент Provider\n\n    Provider делает store доступным всему дереву компонентов (через контекст)\n      - работает так же React Context Provider\n      Любой из компонентов вызовет dispatch над Store и обновит state\n      Provider узнает об обновлении state и обновит приложения\n\n      Компонент Provider отвечает за то, чтобы получать обновления из Store.\n      Затем state передаётся через Context дереву React компонентов.\n      С другой стороны функция connect получает state из Context и передаёт свойства из state\n      нужному компоненту.\n      Если данные в контексте изменяются, то это приводит к перерисовке.\n\n    Каждый помпонент внутри App будет иметь доступ к роутеру, redux store, react-context,\n    если произойдет ошибка она будет отловленна ErrorBoundry.\n    Компоненты зависят от данный в redux store, они могут dispatch новые Action\n*/\n\n// Класс для работы с данными, backend\nconst bookstoreService = new BookstoreService();\n\n// Запуская, инициализирует основные части приложения.\nReactDOM.render(\n  <Provider store={store}>\n    <ErrorBoundry>\n      <BookstoreServiceProvider value={bookstoreService}>\n        <Router>\n          <App />\n        </Router>\n      </BookstoreServiceProvider>\n    </ErrorBoundry>\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}